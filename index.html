<!DOCTYPE html>
<html>
<head>
<title>SYSTEM DETONATION INITIATED!</title>
<style>
  body {
    margin: 0;
    overflow: hidden;
    font-family: 'Consolas', 'Monaco', monospace;
    background-color: #000;
    color: #00ff00;
    display: flex;
    justify-content: center;
    align-items: center;
    min-height: 100vh;
    cursor: none; /* Oculta el cursor por defecto para un efecto más inmersivo */
  }

  #fullscreenOverlay {
    position: fixed;
    top: 0;
    left: 0;
    width: 100%;
    height: 100%;
    background-color: #000;
    color: #00ff00;
    font-family: 'Consolas', 'Monaco', monospace;
    overflow: hidden;
    display: flex;
    flex-direction: column;
    justify-content: flex-start;
    align-items: flex-start;
    padding: 20px;
    box-sizing: border-box;
    /* No hay 'visibility: hidden' ni 'opacity: 0' inicial. Se activa al cargar. */
    z-index: 1000;
  }

  /* Mensaje de BLOQUEO al intentar salir */
  #lockedMessage {
    position: absolute;
    top: 50%;
    left: 50%;
    transform: translate(-50%, -50%);
    font-size: 4em;
    color: #ff0000;
    text-shadow: 0 0 15px #ff0000;
    z-index: 1002;
    opacity: 0;
    visibility: hidden;
    transition: opacity 0.3s ease, visibility 0.3s ease;
    background-color: rgba(0, 0, 0, 0.7);
    padding: 20px 40px;
    border-radius: 15px;
    border: 3px solid #ff0000;
    text-align: center;
  }
  #lockedMessage.show {
    opacity: 1;
    visibility: visible;
  }


  /* Área de la consola para mensajes */
  #consoleArea {
    width: 100%;
    height: calc(100% - 40px); /* Deja espacio para el prompt */
    overflow-y: scroll;
    padding-right: 15px;
    box-sizing: border-box;
    -ms-overflow-style: none;
    scrollbar-width: none;
    position: absolute; /* Para que la lluvia de datos pase por detrás */
    z-index: 1001; /* Asegura que esté por encima de la lluvia de datos */
  }
  #consoleArea::-webkit-scrollbar {
    display: none;
  }

  .console-line {
    white-space: pre-wrap;
    margin-bottom: 3px;
    line-height: 1.2;
    animation: fadeInLine 0.1s forwards; /* Animación más rápida */
    transform: translateY(0); /* Reinicia la transformación */
  }

  @keyframes fadeInLine {
    from { opacity: 0; transform: translateY(5px); } /* Menos desplazamiento */
    to { opacity: 1; transform: translateY(0); }
  }

  .warning { color: #ffcc00; font-weight: bold; }
  .error { color: #ff0000; font-weight: bold; text-shadow: 0 0 5px rgba(255, 0, 0, 0.5); }
  .success { color: #00ff00; font-weight: bold; }
  .antivirus-text { color: #00ffff; font-weight: bold; }
  .data-stream { font-size: 0.9em; color: #009900; white-space: pre; }

  .prompt {
    position: absolute;
    bottom: 20px;
    left: 20px;
    color: #00ff00;
    z-index: 1001;
  }

  .console-cursor {
    display: inline-block;
    width: 0.7em;
    height: 1.2em;
    background-color: #00ff00;
    margin-left: 5px;
    vertical-align: middle;
    animation: blink-cursor 0.75s infinite alternate;
  }

  @keyframes blink-cursor {
    from { opacity: 1; }
    to { opacity: 0; }
  }

  /* --- Ventana de Antivirus Falsa --- */
  #antivirusWindow {
    position: absolute;
    top: 20%;
    left: 50%;
    transform: translateX(-50%);
    width: 500px;
    background-color: #1a1a1a;
    border: 2px solid #00ffff;
    box-shadow: 0 0 25px rgba(0, 255, 255, 0.5), 0 0 15px rgba(255, 0, 255, 0.5);
    padding: 15px;
    box-sizing: border-box;
    z-index: 1003;
    display: none;
    flex-direction: column;
    align-items: center;
    text-align: center;
  }
  #antivirusWindow.active {
    display: flex;
  }

  #antivirusWindow .title-bar {
    width: 100%;
    background-color: #00ffff;
    color: #000;
    padding: 8px 10px;
    font-weight: bold;
    font-size: 1.1em;
    display: flex;
    justify-content: space-between;
    align-items: center;
    margin-bottom: 15px;
  }
  #antivirusWindow .title-bar .close-btn {
    background: none;
    border: none;
    color: #000;
    font-size: 1.5em;
    font-weight: bold;
    cursor: pointer;
    line-height: 1;
  }

  #antivirusWindow .content {
    font-size: 1.1em;
    color: #fff;
    margin-bottom: 15px;
  }
  #antivirusWindow .status-message {
    font-size: 1.3em;
    font-weight: bold;
    margin-top: 10px;
    text-shadow: 0 0 8px rgba(255, 0, 0, 0.7);
  }
  #antivirusWindow .progress-bar {
    width: 80%;
    height: 15px;
    background-color: #333;
    border: 1px solid #00ff00;
    margin-top: 10px;
    overflow: hidden;
  }
  #antivirusWindow .progress-fill {
    width: 0%;
    height: 100%;
    background-color: #00ff00;
    transition: width 0.5s linear;
  }

  /* --- Lluvia de Datos/Texto --- */
  #dataRain {
    position: absolute;
    top: 0;
    left: 0;
    width: 100%;
    height: 100%;
    pointer-events: none;
    overflow: hidden;
    z-index: 999;
  }
  .data-character {
    position: absolute;
    color: rgba(0, 255, 0, 0.3);
    font-size: 1em;
    text-shadow: 0 0 5px rgba(0, 255, 0, 0.5);
    opacity: 0;
    animation: rainFall 5s linear forwards infinite;
    animation-delay: var(--delay);
    animation-duration: var(--duration);
  }

  @keyframes rainFall {
    0% { transform: translateY(-100px) translateX(var(--start-x)); opacity: 0; }
    5% { opacity: 1; }
    95% { opacity: 1; }
    100% { transform: translateY(100vh) translateX(var(--end-x)); opacity: 0; }
  }

  /* --- Countdown de Autodestrucción --- */
  #selfDestructCountdown {
    position: absolute;
    top: 0;
    left: 0;
    width: 100%;
    height: 100%;
    background-color: rgba(0, 0, 0, 0.95);
    display: flex;
    flex-direction: column;
    justify-content: center;
    align-items: center;
    font-size: 15em; /* Muy grande */
    color: #ff0000;
    text-shadow: 0 0 50px rgba(255, 0, 0, 0.9);
    z-index: 1004; /* Más alto que todo */
    opacity: 0;
    visibility: hidden;
    transition: opacity 0.5s ease;
  }
  #selfDestructCountdown.active {
    opacity: 1;
    visibility: visible;
  }
  #selfDestructCountdown .message {
      font-size: 0.2em; /* Mensaje más pequeño */
      color: #ffcc00; /* Amarillo */
      text-shadow: none;
      margin-top: 20px;
  }
</style>
</head>
<body>

<div id="fullscreenOverlay">
  <div id="dataRain"></div>
  <div id="consoleArea">
    <div class="console-line"><span class="success">SYSTEM_INIT: Boot sequence complete.</span></div>
    <div class="console-line"><span class="antivirus-text">[ANTIVIRUS]: Scanning system...</span></div>
  </div>
  <div class="prompt">
    <span style="color: #00ff00;">C:\&gt;</span>
    <span class="console-cursor"></span>
  </div>

  <div id="lockedMessage">
    ACCESO DENEGADO<br>SYSTEM LOCKED
  </div>

  <div id="antivirusWindow">
    <div class="title-bar">
      <span>Windows Defender Security Center</span>
      <button class="close-btn" onclick="alert('Funcionalidad de cierre deshabilitada');">✖</button>
    </div>
    <img src="image_0b5df2.png" alt="Windows Defender Icon" style="width: 80px; height: 80px; margin-bottom: 10px;">
    <div class="content">
      Virus & threat protection
      <div class="status-message" id="antivirusStatus">Virus detected: Trojan:Win32/MalwareX!gfs</div>
      <div class="progress-bar"><div class="progress-fill" id="antivirusProgress"></div></div>
    </div>
  </div>

  <div id="selfDestructCountdown">
      <span id="countdownNumber">5</span>
      <span class="message">PC SELF-DESTRUCT INITIATED</span>
  </div>

</div>

<script>
const fullscreenOverlay = document.getElementById('fullscreenOverlay');
const consoleArea = document.getElementById('consoleArea');
const lockedMessage = document.getElementById('lockedMessage');
const antivirusWindow = document.getElementById('antivirusWindow');
const antivirusStatus = document.getElementById('antivirusStatus');
const antivirusProgress = document.getElementById('antivirusProgress');
const dataRain = document.getElementById('dataRain');
const selfDestructCountdown = document.getElementById('selfDestructCountdown');
const countdownNumber = document.getElementById('countdownNumber');

const antivirusAppearTime = 2000; // La ventana de antivirus aparece después de 2 segundos
const selfDestructTriggerTime = 20000; // La autodestrucción empieza después de 20 segundos de iniciar

const messageIntervalSpeed = 40; // Mensajes de consola cada 40ms (más rápido)

let messageInterval;
let antivirusInterval;
let dataRainInterval;
let selfDestructTimer;

// Mensajes para la consola principal (más variados y caóticos)
const hackermanMessages = [
  '<span class="success">SYSTEM_INIT: Boot sequence complete.</span>',
  '<span class="antivirus-text">[AV_SCAN]: Initiating critical threat assessment.</span>',
  'C:\\&gt; netstat -an -p tcp',
  '  TCP    0.0.0.0:135            0.0.0.0:0              LISTENING',
  '  TCP    192.168.1.100:49152   172.217.160.1:443      ESTABLISHED',
  '<span class="error">ERROR: Unauthorized root access detected from [1.2.3.4]:666.</span>',
  '<span class="warning">WARNING: Core system files are being modified.</span>',
  'C:\\&gt; reg query HKLM\\Software\\Microsoft\\Windows\\CurrentVersion\\Run',
  '<span class="data-stream">  (Default)    REG_SZ    (value not set)</span>',
  '<span class="data-stream">  "MaliciousSvc"    REG_SZ    "C:\\Users\\Public\\mal.exe"</span>',
  '<span class="antivirus-text">[AV_ALERT]: Worm.Win32.Blaster.A - INFECTION CONFIRMED!</span>',
  '<span class="error">CRITICAL_OVERLOAD: CPU at 99.8%, RAM 99.9%. System instability.</span>',
  'C:\\&gt; taskkill /F /IM explorer.exe',
  '<span class="data-stream">  SUCCESS: The process "explorer.exe" with PID 1234 has been terminated.</span>',
  '<span class="warning">ATTENTION: System BIOS integrity check FAILED.</span>',
  '<span class="antivirus-text">[AV_ACTION]: Attempting to isolate network adapter... FAILED.</span>',
  'C:\\&gt; ipconfig /release',
  '<span class="error">NETWORK_ERROR: IP address release failed. Adapter hijacked.</span>',
  '<span class="data-stream">  0x978F0A2B - 0x1A2B3C4D - 0x5E6F7A8B - 0x9C0D1E2F - 0x3G4H5I6J</span>',
  '<span class="warning">WARNING: External device detected and initializing data transfer.</span>',
  'C:\\&gt; format C: /Q /V:DATA_ERASE',
  '<span class="error">PERMISSION_DENIED: Access to drive C: for formatting is denied.</span>',
  '<span class="antivirus-text">[AV_FAIL]: Defender self-protection disabled. MALWARE_CONTROL.</span>',
  '<span class="success">ACCESS: BACKDOOR_OPEN. System remote access enabled.</span>',
  '<span class="data-stream">  INIT_STREAM: Sending all user data to remote_host.</span>',
  '<span class="error">SYSTEM_FAILURE: Imminent shutdown... Forced override.</span>',
  '<span class="warning">ALERT: Unauthorized webcam access. Recording in progress.</span>',
  'C:\\&gt; del *.* /S /Q',
  '<span class="data-stream">  Deleting C:\\Users\\User\\Documents\\Confidential.docx... [OK]</span>',
  '<span class="data-stream">  Deleting C:\\Users\\User\\Pictures\\Vacation.jpg... [OK]</span>',
  '<span class="antivirus-text">[AV_STATUS]: System compromised. Full control lost.</span>',
  'C:\\&gt; ECHO YOUR_SYSTEM_IS_NOW_MINE > C:\\README.TXT'
];

// Mensajes para la ventana de antivirus, simulando el hackeo
const antivirusHackMessages = [
  'Virus detected: Trojan:Win32/MalwareX!gfs',
  '<span class="error">ERROR: Unable to remove threat.</span>',
  '<span class="warning">WARNING: Defender services are being disabled.</span>',
  '<span class="error">CRITICAL: Malware attempting to take control of Defender.</span>',
  'Defender self-protection failed.',
  '<span class="error">REMOTE_ACCESS_ACTIVE: Threat gaining privileges.</span>',
  'Signature updates failed. Connection refused.',
  '<span class="error">DEFENDER_SHUTDOWN_INITIATED...</span>',
  'Virus threat level: MAX',
  'System integrity: COMPROMISED'
];


function addConsoleLine(message) {
  const lineDiv = document.createElement('div');
  lineDiv.classList.add('console-line');
  lineDiv.innerHTML = message;
  consoleArea.appendChild(lineDiv);
  consoleArea.scrollTop = consoleArea.scrollHeight;
}

function startConsoleMessages() {
  let messageIndex = 0;
  messageInterval = setInterval(() => {
    addConsoleLine(hackermanMessages[messageIndex]);
    messageIndex = (messageIndex + 1) % hackermanMessages.length;
  }, messageIntervalSpeed);
}

function stopConsoleMessages() {
  clearInterval(messageInterval);
}

// Lógica de la ventana de antivirus
function activateAntivirusWindow() {
  antivirusWindow.classList.add('active');
  antivirusStatus.innerHTML = antivirusHackMessages[0];
  antivirusProgress.style.width = '20%';
  
  let hackProgressCount = 0;
  antivirusInterval = setInterval(() => {
    hackProgressCount++;
    const statusIdx = hackProgressCount % antivirusHackMessages.length;
    antivirusStatus.innerHTML = antivirusHackMessages[statusIdx];
    
    let currentProgress = parseInt(antivirusProgress.style.width);
    if (hackProgressCount < 10) { // Primeros ~7 segundos, avanza
      antivirusProgress.style.width = `${Math.min(80, currentProgress + 5)}%`;
      antivirusProgress.style.backgroundColor = '#00ff00';
    } else { // Después, el virus empieza a ganar
      antivirusProgress.style.width = `${Math.max(0, currentProgress - 8)}%`; // Retrocede más rápido
      antivirusProgress.style.backgroundColor = '#ff0000';
      antivirusStatus.style.textShadow = '0 0 10px rgba(255,0,0,0.9)';
    }
    
  }, 700);
}

function stopAntivirusWindow() {
  clearInterval(antivirusInterval);
  antivirusWindow.classList.remove('active');
  antivirusProgress.style.width = '0%';
  antivirusProgress.style.backgroundColor = '#00ff00';
  antivirusStatus.style.textShadow = 'none';
}

// Lógica para la lluvia de datos
const characters = "0123456789ABCDEF!@#$%^&*()_+{}[]|:;<>?/.,`~";
function createDataCharacter() {
    const char = characters.charAt(Math.floor(Math.random() * characters.length));
    const span = document.createElement('span');
    span.classList.add('data-character');
    span.textContent = char;

    const startX = Math.random() * 100;
    const endX = Math.random() * 100;
    const delay = Math.random() * 5;
    const duration = 5 + Math.random() * 10;

    span.style.setProperty('--start-x', `${startX}vw`);
    span.style.setProperty('--end-x', `${endX}vw`);
    span.style.setProperty('--delay', `${delay}s`);
    span.style.setProperty('--duration', `${duration}s`);
    span.style.left = `${Math.random() * 100}vw`;
    span.style.fontSize = `${0.8 + Math.random() * 1.2}em`;

    dataRain.appendChild(span);

    span.addEventListener('animationend', () => {
        span.remove();
    });
}

function startDataRain() {
    dataRainInterval = setInterval(createDataCharacter, 50);
}

function stopDataRain() {
    clearInterval(dataRainInterval);
    dataRain.innerHTML = '';
}

// Lógica de Autodestrucción
function startSelfDestructCountdown() {
    selfDestructCountdown.classList.add('active');
    let count = 5;
    countdownNumber.textContent = count;

    selfDestructTimer = setInterval(() => {
        count--;
        countdownNumber.textContent = count;
        if (count <= 0) {
            clearInterval(selfDestructTimer);
            selfDestructCountdown.classList.remove('active');
            // ÚNICA salida del modo pantalla completa
            if (document.fullscreenElement || document.mozFullScreenElement || document.webkitFullscreenElement || document.msFullscreenElement) {
                if (document.exitFullscreen) {
                    document.exitFullscreen();
                } else if (document.mozCancelFullScreen) {
                    document.mozCancelFullScreen();
                } else if (document.webkitExitFullscreen) {
                    document.webkitExitFullscreen();
                } else if (document.msExitFullscreen) {
                    document.msExitFullscreen();
                }
            }
            // Después de la cuenta regresiva, reseteamos el modo (limpiar intervalos, etc.)
            // Esto es crucial para que si la página se recarga, empiece de nuevo limpia
            resetHackermanMode();
        }
    }, 1000);
}

// Función principal para activar el modo
function activateHackermanMode() {
  fullscreenOverlay.classList.add('active'); // Asegura que el overlay es visible

  // Request fullscreen automáticamente
  const requestFullscreen = () => {
    if (fullscreenOverlay.requestFullscreen) {
      fullscreenOverlay.requestFullscreen();
    } else if (fullscreenOverlay.mozRequestFullScreen) {
      fullscreenOverlay.mozRequestFullScreen();
    } else if (fullscreenOverlay.webkitRequestFullscreen) {
      fullscreenOverlay.webkitRequestFullscreen();
    } else if (fullscreenOverlay.msRequestFullscreen) {
      fullscreenOverlay.msRequestFullscreen();
    }
  };

  requestFullscreen(); // Intenta entrar en fullscreen al inicio

  startConsoleMessages();
  startDataRain();

  // Aparición de la ventana de antivirus
  setTimeout(activateAntivirusWindow, antivirusAppearTime);

  // Inicio de la cuenta regresiva de autodestrucción
  setTimeout(() => {
      startSelfDestructCountdown();
  }, selfDestructTriggerTime);
}

// Función para reiniciar el modo (limpia todos los intervalos y estados)
// Se llama al final de la autodestrucción para limpiar todo.
function resetHackermanMode() {
    stopConsoleMessages();
    stopAntivirusWindow();
    stopDataRain();
    clearInterval(selfDestructTimer); // Asegura que no haya un timer corriendo

    // Reiniciar el estado visual de la consola para la próxima vez que se active (si la página se recarga)
    consoleArea.innerHTML = '<div class="console-line"><span class="success">SYSTEM_INIT: Boot sequence complete.</span></div><div class="console-line"><span class="antivirus-text">[ANTIVIRUS]: Scanning system...</span></div>';
    countdownNumber.textContent = '5'; // Resetear el número para la próxima vez
    selfDestructCountdown.classList.remove('active'); // Ocultar la cuenta regresiva

    // No ocultamos el fullscreenOverlay aquí, ya que el único escape es la autodestrucción
    // y si la persona saliera con ESC/F11, intentaremos meterla de nuevo.
}


// --- Manejo de la salida de pantalla completa por parte del usuario ---
document.addEventListener('keydown', (event) => {
    // Si la tecla es ESC o F11
    if (event.key === 'Escape' || event.key === 'F11') {
        event.preventDefault(); // Intenta prevenir la acción por defecto
        showLockedMessage(); // Muestra el mensaje de bloqueo

        // Importante: No llamamos a exitFullscreen aquí, lo dejamos al navegador
        // y el listener handleFullscreenExit se encargará de volver a entrar
        // si el usuario logra salir.
    }
});

function showLockedMessage() {
    lockedMessage.classList.add('show');
    setTimeout(() => {
        lockedMessage.classList.remove('show');
    }, 2000);
}

// Eventos para detectar la salida de pantalla completa por el navegador
document.addEventListener('fullscreenchange', handleFullscreenExit);
document.addEventListener('webkitfullscreenchange', handleFullscreenExit);
document.addEventListener('mozfullscreenchange', handleFullscreenExit);
document.addEventListener('MSFullscreenChange', handleFullscreenExit);

function handleFullscreenExit() {
    // Si ya NO estamos en pantalla completa Y el overlay está activo (significa que la simulación sigue)
    // Entonces, intentamos volver a entrar en pantalla completa inmediatamente después de un breve retraso.
    // El retraso evita un bucle demasiado rápido y le da tiempo al navegador a procesar la salida.
    if (!document.fullscreenElement && !document.mozFullScreenElement && !document.webkitFullscreenElement && !document.msFullscreenElement) {
        // Solo si la simulación está activa (no ha terminado con la autodestrucción)
        // Y el overlay aún está visible (ya que al final de la autodestrucción lo limpiamos todo)
        if (fullscreenOverlay.classList.contains('active') && !selfDestructCountdown.classList.contains('active')) {
            setTimeout(() => {
                if (fullscreenOverlay.requestFullscreen) {
                    fullscreenOverlay.requestFullscreen();
                } else if (fullscreenOverlay.mozRequestFullScreen) {
                    fullscreenOverlay.mozRequestFullScreen();
                } else if (fullscreenOverlay.webkitRequestFullscreen) {
                    fullscreenOverlay.webkitRequestFullscreen();
                } else if (fullscreenOverlay.msRequestFullscreen) {
                    fullscreenOverlay.msRequestFullscreen();
                }
            }, 100); // Intenta re-entrar después de 100ms
            // Opcional: Podrías mostrar el lockedMessage aquí también si quieres que aparezca cada vez que lo intenten
            // showLockedMessage();
        }
    }
    // Si la simulación terminó (por la autodestrucción), `resetHackermanMode` ya se encargó de limpiar
    // y no intentaremos re-entrar.
}

// Activar el modo Hackerman automáticamente cuando la página carga
document.addEventListener('DOMContentLoaded', activateHackermanMode);

</script>

</body>
</html>
